import express from 'express';
import dotenv from 'dotenv';
import pool from './config/db.js';
import authRouter from './routes/authRoute.js';
import PermissionRouter from './routes/PermissionRoute.js';
import pompeRouter from './routes/PompeRoute.js';
import pistoletRouter from './routes/PistoletRoute.js';
import creditRouter from './routes/GestionCreditRoute.js';
import notificationRouter from './routes/NotificationRoute.js';
import AffectationCalendrierRouter from './routes/AffectationCalendrierRoute.js';
import passport from './config/passport.js';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import path from 'path';
import cron from 'node-cron';
import Credit from './models/Credit.js';
import Notification from './models/Notification.js';
import nodemailer from 'nodemailer';
import fs from 'fs';
import swaggerUi from 'swagger-ui-express';
import swaggerSpec from './swagger-config.js';
import stockRouter from './routes/stockRoute.js';
import reclamationRouter from './routes/reclamationRoute.js';
import messageRouter from './routes/messageRoute.js';
//import OdooService from './services/OdooService.js';
//import odooRouter from './routes/odooRoute.js';
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration du transporteur email
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

// Middlewares
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(
  cors({
    origin: ['http://localhost:4200', 'https://www.getpostman.com'], // Autorise √† la fois Angular
    methods: 'GET,POST,PUT,DELETE',
    allowedHeaders: 'Content-Type, Authorization',
    credentials: true,
  }),
);
app.use(cookieParser());
app.use(passport.initialize());

// Routes
app.use('/api', authRouter);
app.use('/api', PermissionRouter);
app.use('/api/pompe', pompeRouter);
app.use('/api/pistolet', pistoletRouter);
app.use('/api/affectations', AffectationCalendrierRouter);
app.use('/api/credit', creditRouter);
app.use('/api/stock', stockRouter);
app.use('/api/Reclamation', reclamationRouter);
app.use('/api/notifications', notificationRouter);
app.use('/api/messages', messageRouter);

// Ajoutez cette ligne APR√àS les autres app.use() et AVANT les routes
app.use(
  '/api-docs',
  swaggerUi.serve,
  swaggerUi.setup(swaggerSpec, {
    swaggerOptions: {
      withCredentials: true, // Essentiel pour les cookies
      persistAuthorization: true, // Garde l'authentification entre les rafra√Æchissements
    },
    customSiteTitle: 'API Carbotrack Documentation',
    customCss: '.swagger-ui .topbar { display: none }',
  }),
);
//app.use('/api/odoo', odooRouter);
// Ensure uploads directory exists
const uploadsDir = path.join(process.cwd(), 'public/transactions');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}
// Static files
const __dirname = path.resolve();
app.use('/images', express.static(path.join(__dirname, 'public/images')));
app.use('/qrcodes', express.static(path.join(__dirname, 'public/qrcodes')));
app.use('/transactions', express.static(path.join(__dirname, 'public/transactions')));
app.use('/images_produits', express.static(path.join(__dirname, 'public/images_produits')));

// Database connection check
(async () => {
  try {
    await pool.query('SELECT 1');
    console.log('‚úÖ Database connection successful');
  } catch (err) {
    console.error('‚ùå Database connection error:', err);
    process.exit(1);
  }
})();

// V√©rification de la connexion Odoo
//(async () => {
//try {
//const result = await OdooService.testConnection();

//if (result.success) {
//console.log('‚úÖ Odoo connection successful', {
//uid: result.uid,
//version: result.version.server_version,
//database: result.db
//});
//} else {
//console.error('‚ùå Odoo connection failed:', result.error);
// Optionnel: arr√™ter le serveur si Odoo est essentiel
// process.exit(1);
//}
//} catch (err) {
//console.error('‚ùå Odoo connection error:', err);
//}
//})();

// Fonction pour envoyer des emails de notification
const sendNotificationEmail = async (userId, subject, message) => {
  try {
    const [user] = await pool.query('SELECT email, username FROM utilisateurs WHERE id = ?', [
      userId,
    ]);

    if (user && user[0] && user[0].email) {
      const emailContent = `
        <p>Bonjour ${user[0].username},</p>
        ${message}
      `;

      await transporter.sendMail({
        from: `"Carbotrack" <${process.env.EMAIL_USER}>`,
        to: user[0].email,
        subject: subject,
        html: emailContent,
      });
    }
  } catch (err) {
    console.error('Erreur envoi email notification:', err);
  }
};
// Nouveau CRON Job pour d√©sactiver les comptes avec plus de 2 cr√©dits expir√©s
cron.schedule('0 3 * * *', async () => {
  // Tous les jours √† 3h du matin
  try {
    console.log('üîÑ V√©rification des comptes avec cr√©dits expir√©s...');

    // 1. Trouver les utilisateurs avec plus de 2 cr√©dits expir√©s
    const [usersWithExpiredCredits] = await pool.query(`
      SELECT 
        u.id, 
        u.username, 
        u.email, 
        u.status,
        COUNT(dc.id) AS expired_credits_count
      FROM utilisateurs u
      JOIN details_credits dc ON u.id = dc.id_utilisateur
      WHERE dc.etat = 'expir√©'
      AND u.role = 'client'
      AND u.status = 'active'
      GROUP BY u.id
      HAVING COUNT(dc.id) > 2
    `);

    // R√©cup√©rer l'ID du g√©rant
    const [gerant] = await pool.query(`
      SELECT id FROM utilisateurs 
      WHERE role = 'gerant' 
      LIMIT 1
    `);

    const gerantId = gerant[0]?.id;

    for (const user of usersWithExpiredCredits) {
      // 2. D√©sactiver le compte
      await pool.query(`UPDATE utilisateurs SET status = 'inactive' WHERE id = ?`, [user.id]);

      // 3. Cr√©er une notification pour le g√©rant
      if (gerantId) {
        await Notification.create(
          gerantId, // ID du g√©rant comme destinataire
          'systeme',
          user.id, // ID du client comme entit√© concern√©e
          'compte_desactive',
          `Le compte client ${user.username} (ID: ${user.id}) a √©t√© d√©sactiv√© automatiquement pour ${user.expired_credits_count} cr√©dits expir√©s`,
        );
      }

      // 4. Envoyer un email au client (optionnel)
      await sendNotificationEmail(
        user.id,
        'Compte d√©sactiv√©',
        `<p>Votre compte a √©t√© d√©sactiv√© automatiquement car vous avez ${user.expired_credits_count} cr√©dits expir√©s.</p>
         <p>Veuillez contacter le support pour plus d'informations.</p>`,
      );

      console.log(
        `Compte d√©sactiv√©: ${user.username} (${user.expired_credits_count} cr√©dits expir√©s)`,
      );
    }

    console.log('‚úÖ V√©rification des comptes avec cr√©dits expir√©s termin√©e');
  } catch (err) {
    console.error('‚ùå Erreur lors de la v√©rification des comptes:', err);
  }
});
// CRON Jobs for automated notifications
cron.schedule('0 0 * * *', async () => {
  // Daily at midnight
  try {
    console.log('üîÑ Running daily credit checks...');

    // 1. Process expired credits
    const [expiredCredits] = await pool.query(`
      SELECT dc.id, dc.id_utilisateur, dc.date_debut, dc.duree_credit, u.username 
      FROM details_credits dc
      JOIN utilisateurs u ON dc.id_utilisateur = u.id
      WHERE dc.etat = 'actif'
      AND DATE_ADD(dc.date_debut, INTERVAL dc.duree_credit DAY) < CURDATE()
    `);

    for (const credit of expiredCredits) {
      // Mark as expired
      await pool.query(`UPDATE details_credits SET etat = 'expir√©' WHERE id = ?`, [credit.id]);

      // Send expiration notification
      await Notification.create(
        credit.id_utilisateur,
        'credit',
        credit.id,
        'expiration',
        `Votre cr√©dit #${credit.id} a expir√©`,
      );

      // Send email
      await sendNotificationEmail(
        credit.id_utilisateur,
        'Votre cr√©dit a expir√©',
        `<p>Votre cr√©dit #${credit.id} a expir√© le ${new Date(
          new Date(credit.date_debut).getTime() + credit.duree_credit * 24 * 60 * 60 * 1000,
        ).toLocaleDateString('fr-FR')}</p>`,
      );
    }

    // 2. Credits expiring soon (3-7 days)
    const [expiringSoon] = await pool.query(`
      SELECT dc.id, dc.id_utilisateur, dc.date_debut, dc.duree_credit, u.username,
      DATEDIFF(DATE_ADD(dc.date_debut, INTERVAL dc.duree_credit DAY), CURDATE()) AS days_remaining
      FROM details_credits dc
      JOIN utilisateurs u ON dc.id_utilisateur = u.id
      WHERE dc.etat = 'actif'
      AND DATEDIFF(DATE_ADD(dc.date_debut, INTERVAL dc.duree_credit DAY), CURDATE()) BETWEEN 3 AND 7
    `);

    for (const credit of expiringSoon) {
      await Notification.create(
        credit.id_utilisateur,
        'credit',
        credit.id,
        'expiration_proche',
        `Votre cr√©dit #${credit.id} expire dans ${credit.days_remaining} jours`,
      );

      await sendNotificationEmail(
        credit.id_utilisateur,
        'Cr√©dit bient√¥t expir√©',
        `<p>Votre cr√©dit #${credit.id} expire dans ${credit.days_remaining} jours</p>`,
      );
    }

    console.log('‚úÖ Daily credit checks completed');
  } catch (err) {
    console.error('‚ùå Error in daily credit checks:', err);
  }
});

// Hourly checks
cron.schedule('0 * * * *', async () => {
  try {
    console.log('üîÑ Running hourly notifications check...');

    // 1. Recently repaid credits (last hour)
    const [recentlyPaid] = await pool.query(`
      SELECT dc.id, dc.id_utilisateur, u.username 
      FROM details_credits dc
      JOIN utilisateurs u ON dc.id_utilisateur = u.id
      WHERE dc.etat = 'rembours√©'
      AND dc.date_dernier_paiement >= NOW() - INTERVAL 1 HOUR
    `);

    for (const credit of recentlyPaid) {
      await Notification.create(
        credit.id_utilisateur,
        'credit',
        credit.id,
        'remboursement',
        `Votre cr√©dit #${credit.id} a √©t√© compl√®tement rembours√©`,
      );

      await sendNotificationEmail(
        credit.id_utilisateur,
        'Cr√©dit rembours√©',
        `<p>Votre cr√©dit #${credit.id} a √©t√© compl√®tement rembours√©</p>`,
      );
    }

    console.log('‚úÖ Hourly notifications check completed');
  } catch (err) {
    console.error('‚ùå Error in hourly notifications check:', err);
  }
});
// CRON Job pour les alertes de stock et r√©approvisionnement automatique
cron.schedule('0 * * * *', async () => {
  try {
    console.log('üîÑ V√©rification des produits sous le seuil et r√©approvisionnement automatique...');

    // 1. R√©cup√©rer les produits sous le seuil d'alerte avec info fournisseur
    const [lowStockProducts] = await pool.query(`
      SELECT 
        p.id,
        p.nom,
        p.quantite_stock,
        p.seuil_alerte,
        p.prix_achat,
        p.fournisseur_id,
        p.categorie_id,
        c.nom AS categorie_nom,
        f.nom AS fournisseur_nom,
        f.email AS fournisseur_email
      FROM produits p
      JOIN categories c ON p.categorie_id = c.id
      LEFT JOIN fournisseurs f ON p.fournisseur_id = f.id
      WHERE p.quantite_stock <= p.seuil_alerte
      AND p.seuil_alerte > 0
    `);

    // 2. R√©cup√©rer l'ID du g√©rant
    const [gerant] = await pool.query(`
      SELECT id FROM utilisateurs 
      WHERE role = 'gerant' 
      LIMIT 1
    `);

    const gerantId = gerant[0]?.id;

    if (!gerantId) {
      console.log('Aucun g√©rant trouv√© pour envoyer les notifications');
      return;
    }

    // 3. Grouper les produits par fournisseur pour le r√©approvisionnement
    const produitsParFournisseur = {};
    const produitsANotifier = [];

    for (const product of lowStockProducts) {
      // V√©rifier si une notification existe d√©j√† pour ce produit
      const [existingNotification] = await pool.query(
        `
        SELECT id FROM notifications
        WHERE entity_type = 'stock' 
        AND entity_id = ?
        AND type = 'alerte_stock'
        AND vue = 0
        AND created_at >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
        LIMIT 1
      `,
        [product.id],
      );

      // Si aucune notification r√©cente n'existe, en cr√©er une nouvelle
      if (!existingNotification || existingNotification.length === 0) {
        const message =
          `Produit "${product.nom}" (${product.categorie_nom}) sous le seuil: ` +
          `${product.quantite_stock} restants (seuil: ${product.seuil_alerte})`;

        await Notification.create(gerantId, 'stock', product.id, 'alerte_stock', message);

        console.log(`Notification cr√©√©e pour: ${product.nom}`);

        // Envoyer un email au g√©rant
        await sendNotificationEmail(
          gerantId,
          `Alerte stock: ${product.nom}`,
          `<p>Le produit <strong>${product.nom}</strong> (${product.categorie_nom}) est sous le seuil d'alerte.</p>
           <p>Stock actuel: ${product.quantite_stock}</p>
           <p>Seuil d'alerte: ${product.seuil_alerte}</p>`,
        );

        produitsANotifier.push(product);
      }

      // Grouper par fournisseur pour cr√©er des commandes automatiques
      if (product.fournisseur_id) {
        if (!produitsParFournisseur[product.fournisseur_id]) {
          produitsParFournisseur[product.fournisseur_id] = {
            fournisseur_nom: product.fournisseur_nom,
            fournisseur_email: product.fournisseur_email,
            produits: []
          };
        }
        
        // V√©rifier s'il n'existe pas d√©j√† une commande r√©cente pour ce produit
        const [existingOrder] = await pool.query(`
          SELECT ca.id 
          FROM commandes_achat ca
          JOIN ligne_commande lc ON ca.id = lc.commande_id
          WHERE lc.produit_id = ? 
          AND ca.statut IN ('brouillon', 'valid√©e')
          AND ca.date_commande >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
          LIMIT 1
        `, [product.id]);

        // Si pas de commande r√©cente, ajouter le produit au r√©approvisionnement
        if (!existingOrder || existingOrder.length === 0) {
          const quantiteCommande = product.seuil_alerte * 2; // Double du seuil d'alerte
          produitsParFournisseur[product.fournisseur_id].produits.push({
            produit_id: product.id,
            nom: product.nom,
            quantite: quantiteCommande,
            prix_unitaire: product.prix_achat || 0
          });
        }
      }
    }

    // 4. Cr√©er des commandes d'achat automatiques pour chaque fournisseur
    for (const [fournisseurId, data] of Object.entries(produitsParFournisseur)) {
      if (data.produits.length > 0) {
        try {
          // Importer le mod√®le Stock dynamiquement pour √©viter les probl√®mes de circular import
          const { default: Stock } = await import('./models/stockModel.js');
          
          const commandeData = {
            fournisseur_id: parseInt(fournisseurId),
            produits: data.produits,
            agent_id: null // Commande automatique, pas d'agent sp√©cifique
          };

          const commande = await Stock.createCommandeAchat(commandeData);
          
          console.log(`‚úÖ Commande automatique cr√©√©e: #${commande.id} pour ${data.fournisseur_nom}`);

          // Cr√©er une notification de r√©approvisionnement pour le g√©rant
          const reapproMessage = `Commande automatique #${commande.id} cr√©√©e pour ${data.fournisseur_nom}. ${data.produits.length} produit(s) command√©(s).`;
          
          await Notification.create(gerantId, 'stock', commande.id, 'r√©approvisionnement', reapproMessage);

          // Envoyer email de notification au g√©rant
          const produitsListe = data.produits.map(p => 
            `- ${p.nom}: ${p.quantite} unit√©s √† ${p.prix_unitaire}‚Ç¨`
          ).join('\n');

          await sendNotificationEmail(
            gerantId,
            `Commande automatique cr√©√©e: #${commande.id}`,
            `<h3>Commande d'achat automatique cr√©√©e</h3>
             <p><strong>Fournisseur:</strong> ${data.fournisseur_nom}</p>
             <p><strong>Num√©ro de commande:</strong> #${commande.id}</p>
             <p><strong>Montant total:</strong> ${commande.montant_total}‚Ç¨</p>
             <h4>Produits command√©s:</h4>
             <pre>${produitsListe}</pre>
             <p><em>Cette commande a √©t√© cr√©√©e automatiquement suite √† la d√©tection de produits sous le seuil d'alerte.</em></p>`
          );

          // Envoyer email au fournisseur si l'email est disponible
          if (data.fournisseur_email) {
            try {
              const fournisseurEmail = {
                from: `"Station-service" <${process.env.EMAIL_USER}>`,
                to: data.fournisseur_email,
                subject: `Nouvelle commande d'achat #${commande.id}`,
                html: `
                  <h2>Nouvelle commande d'achat</h2>
                  <p>Bonjour,</p>
                  <p>Nous avons cr√©√© une nouvelle commande d'achat:</p>
                  <ul>
                    <li><strong>Num√©ro de commande:</strong> #${commande.id}</li>
                    <li><strong>Date:</strong> ${new Date().toLocaleDateString('fr-FR')}</li>
                    <li><strong>Montant total:</strong> ${commande.montant_total}DT</li>
                  </ul>
                  <h3>Produits command√©s:</h3>
                  <table border="1" style="border-collapse: collapse; width: 100%;">
                    <tr style="background-color: #f2f2f2;">
                      <th style="padding: 8px;">Produit</th>
                      <th style="padding: 8px;">Quantit√©</th>
                      <th style="padding: 8px;">Prix unitaire</th>
                      <th style="padding: 8px;">Total</th>
                    </tr>
                    ${data.produits.map(p => `
                      <tr>
                        <td style="padding: 8px;">${p.nom}</td>
                        <td style="padding: 8px;">${p.quantite}</td>
                        <td style="padding: 8px;">${p.prix_unitaire}DT</td>
                        <td style="padding: 8px;">${(p.quantite * p.prix_unitaire).toFixed(2)}DT</td>
                      </tr>
                    `).join('')}
                  </table>
                  <p>Merci de confirmer la r√©ception de cette commande.</p>
                  <p>Cordialement,<br>L'√©quipe de gestion</p>
                `
              };

              await transporter.sendMail(fournisseurEmail);
              console.log(`üìß Email envoy√© au fournisseur: ${data.fournisseur_email}`);
            } catch (emailError) {
              console.error(`‚ùå Erreur envoi email fournisseur ${data.fournisseur_email}:`, emailError);
            }
          }

        } catch (commandeError) {
          console.error(`‚ùå Erreur cr√©ation commande pour fournisseur ${data.fournisseur_nom}:`, commandeError);
        }
      }
    }

    console.log(`‚úÖ V√©rification termin√©e: ${lowStockProducts.length} produits sous le seuil, ${Object.keys(produitsParFournisseur).length} fournisseurs trait√©s`);
  } catch (err) {
    console.error('‚ùå Erreur lors de la v√©rification du stock et r√©approvisionnement:', err);
  }
});
// Weekly summary every Monday at 9 AM
cron.schedule('0 9 * * 1', async () => {
  try {
    console.log('üîÑ Running weekly summary...');

    // Get all active users
    const [users] = await pool.query(`
      SELECT id, username, email FROM utilisateurs WHERE status = 'active'
    `);

    for (const user of users) {
      // Get weekly stats - Version corrig√©e
      const [[{ transactions }]] = await pool.query(
        `
        SELECT COUNT(*) AS transactions 
        FROM transactions t
        JOIN details_credits dc ON t.id_credit = dc.id
        WHERE dc.id_utilisateur = ? 
        AND t.date_transaction >= DATE_SUB(NOW(), INTERVAL 7 DAY)
      `,
        [user.id],
      );

      const [[{ payments }]] = await pool.query(
        `
        SELECT SUM(montant_paye) AS payments 
        FROM paiements_credits 
        WHERE id_utilisateur = ? 
        AND date_paiement >= DATE_SUB(NOW(), INTERVAL 7 DAY)
      `,
        [user.id],
      );

      await Notification.create(
        user.id,
        'systeme',
        null,
        'resume_hebdo',
        `R√©sum√© hebdomadaire: ${transactions} transactions, ${payments || 0} DT pay√©s`,
      );

      if (user.email) {
        await transporter.sendMail({
          from: `"Carbotrack" <${process.env.EMAIL_USER}>`,
          to: user.email,
          subject: 'Votre r√©sum√© hebdomadaire',
          html: `
            <p>Bonjour ${user.username},</p>
            <p>Votre activit√© cette semaine :</p>
            <ul>
              <li>Transactions: ${transactions}</li>
              <li>Montant pay√©: ${payments || 0} DT</li>
            </ul>
          `,
        });
      }
    }
  
    console.log('‚úÖ Weekly summary completed');
  } catch (err) {
    console.error('‚ùå Error in weekly summary:', err);
  }
});
app.listen(PORT, () => {
  console.log(`üöÄ Server running on http://localhost:${PORT}`);
});

export default app;
